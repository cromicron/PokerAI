import copy
from new_game_dialog import Ui_Dialog
from poker_table import Ui_MainWindow
from PySide2.QtWidgets import QDialog, QApplication, QMainWindow, QLabel, QLineEdit, QSlider, QSpinBox
from PySide2.QtGui import QPixmap, QDoubleValidator
from PySide2.QtCore import Qt, QTimer
from PokerGame.NLHoldem import Game, value_dict, suit_dict
from agents.gru_agent import Agent
from policies.mixed_gru_policy import MixedGruPolicy
from value_functions.gru_value_function import GRUValueFunction
from encoders.state_encoder import encode_state
from encoders.strength_encoder import encode_strength
import numpy as np
import torch

class GameSetupDialog(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.ui = Ui_Dialog()  # I'm assuming Ui_Dialog is a class generated by Qt Designer
        self.ui.setupUi(self)

        self.ui.okButton.clicked.connect(self.accept)
        self.ui.cancelButton.clicked.connect(self.reject)
        self.ui.spinBoxNumPlayers.valueChanged.connect(self.on_number_of_players_changed)

        # Assuming chipstacksFrame has a QVBoxLayout set in Qt Designer
        self.chipstacks_layout = self.ui.chipstacksFrame.layout()

        # Initialize with the current number of players
        self.on_number_of_players_changed(self.ui.spinBoxNumPlayers.value())


    def get_inputs(self):
        # Retrieve the values from the dynamically created spin boxes for starting stacks
        starting_stacks = [spinbox.value() for spinbox in self.get_player_stack_spinboxes()]

        return {
            'num_players': self.ui.spinBoxNumPlayers.value(),
            'starting_stacks': starting_stacks,
            'username': self.ui.lineEditUsername.text()
        }

    def get_player_stack_spinboxes(self):
        # Helper function to retrieve all player stack spin boxes from the layout
        return [self.chipstacks_layout.itemAt(i).widget() for i in range(self.chipstacks_layout.count())]

    def on_number_of_players_changed(self, number_of_players):
        # First, clear out any existing spin boxes
        while self.chipstacks_layout.count():
            child = self.chipstacks_layout.takeAt(0).widget()
            if child:
                child.deleteLater()

        # Then create a new set of spin boxes for the new number of players
        for player_number in range(1, number_of_players + 1):
            player_stack_spinbox = QSpinBox()
            player_stack_spinbox.setMinimum(5)  # Minimum starting stack
            player_stack_spinbox.setMaximum(1000)
            player_stack_spinbox.setValue(100)  # Default starting stack value
            player_stack_spinbox.setSuffix(" Chips")  # Suffix for the spin box
            self.chipstacks_layout.addWidget(player_stack_spinbox)  # Add the spin box to the layout
class PokerWindow(QMainWindow, Ui_MainWindow):
    def __init__(self, username, game_instance, parent=None, n_players = 9):
        super(PokerWindow, self).__init__(parent)
        self.game = game_instance
        self.setupUi(self)  # this sets up the GUI as defined in Qt Designer
        self.labelPlayerName_0.setText(username)
        # Connect signals to your slots here
        self.foldButton.clicked.connect(self.fold)
        self.checkCallButton.clicked.connect(self.call)
        self.betRaiseButton.clicked.connect(self.raiseBet)
        self.buttonNextHand.clicked.connect(self.deal_new_hand)



        self.raiseAmountLineEdit = self.findChild(QLineEdit, 'raiseAmountLineEdit')
        # Sync the QLineEdit with the QSlider

        self.raiseAmountLineEdit = self.findChild(QLineEdit, 'raiseAmountLineEdit')
        self.betSizeSlider = self.findChild(QSlider, 'betSizeSlider')
        self.raiseAmountLineEdit.textEdited.connect(self.onRaiseAmountEdited)
        self.betSizeSlider.valueChanged.connect(self.onSliderValueChanged)

        # Set up a double validator with a range and two decimal places
        double_validator = QDoubleValidator(0.1, 10000.0, 2, self.raiseAmountLineEdit)
        double_validator.setNotation(QDoubleValidator.StandardNotation)
        self.raiseAmountLineEdit.setValidator(double_validator)



        self.player_elements = {
            0: {"widget": self.player0, 'cards': [self.holecardP00, self.holecardP01], "button": self.button0, "bet": self.bet_0, "action_label": self.check_0},
            1: {"widget": self.player1, 'cards': [self.holecardP10, self.holecardP11], "button": self.button1, "bet": self.bet_1, "action_label": self.check_1},
            2: {"widget": self.player2, 'cards': [self.holecardP20, self.holecardP21], "button": self.button2, "bet": self.bet_2, "action_label": self.check_2},
            3: {"widget": self.player3, 'cards': [self.holecardP30, self.holecardP31], "button": self.button3, "bet": self.bet_3, "action_label": self.check_3},
            4: {"widget": self.player4, 'cards': [self.holecardP40, self.holecardP41], "button": self.button4, "bet": self.bet_4, "action_label": self.check_4},
            5: {"widget": self.player5, 'cards': [self.holecardP50, self.holecardP51], "button": self.button5, "bet": self.bet_5, "action_label": self.check_5},
            6: {"widget": self.player6, 'cards': [self.holecardP60, self.holecardP61], "button": self.button6, "bet": self.bet_6, "action_label": self.check_6},
            7: {"widget": self.player7, 'cards': [self.holecardP70, self.holecardP71], "button": self.button7, "bet": self.bet_7, "action_label": self.check_7},
            8: {"widget": self.player8, 'cards': [self.holecardP80, self.holecardP81], "button": self.button8, "bet": self.bet_8, "action_label": self.check_8},
        }

        self._adjustTableForLessPlayers(n_players)

        self.hideHud.stateChanged.connect(self.toggle_hud)  # No need for findChild!


        # generate dict for all geometries
        self.geometries = {i: {} for i in range(n_players)}
        for i in range(n_players):
            elements = self.player_elements[i].items()
            for key, value in elements:
                if type(value) != list:
                    self.geometries[i][key] = copy.deepcopy(value.geometry())
                else:
                    self.geometries[i][key] = []
                    for j in range(len(value)):
                        self.geometries[i][key].append(copy.deepcopy(value[j].geometry()))

    def toggle_hud(self, state):
        """Enable or disable the grid based on checkbox state."""
        self.hud.setVisible(state == 2)  # 2 means checked

    def onRaiseAmountEdited(self, text):
        # Convert text to a float value and update the slider's position
        value = float(text) if text else 0
        self.betSizeSlider.setValue(int(value))  # Assumes the slider uses integer values

    def onSliderValueChanged(self, value):
        # Update the line edit whenever the slider value changes
        self.raiseAmountLineEdit.setText(f"{value:.2f}")  # Assuming you want to show float values with two decimal places


    def hidePlayerElements(self, player):
        # Hide all player elements
        elements = self.player_elements[player].items()
        for key, value in elements:
            if type(value) != list:
                value.setVisible(False)
            else:
                for element in value:
                    element.setVisible(False)

    def _switch_positions(self, from_player, to_player):
        elements_from = self.player_elements[from_player]
        elements_to = self.player_elements[to_player].items()
        for key, value in elements_to:
            if type(value) != list:
                position = value.geometry()
                elements_from[key].setGeometry(position)
            else:
                for i in range(len(value)):
                    position = value[i].geometry()
                    elements_from[key][i].setGeometry(position)


    def _adjustTableForLessPlayers(self, n_players):
        # Reposition and hide logic here
        players_hide = list(range(n_players,9))
        for player in players_hide:
            self.hidePlayerElements(player)
        if n_players == 2:
            self._switch_positions(1,5)
        elif n_players == 3:
            self._switch_positions(1, 4)
            self._switch_positions(2, 6)
        elif n_players == 4:
            self._switch_positions(1, 2)
            self._switch_positions(2, 5)
            self._switch_positions(3, 7)
        elif n_players == 5:
            self._switch_positions(1, 2)
            self._switch_positions(2, 4)
            self._switch_positions(3, 6)
            self._switch_positions(4, 7)
        elif n_players == 6:
            self._switch_positions(1, 2)
            self._switch_positions(2, 3)
            self._switch_positions(3, 5)
            self._switch_positions(4, 7)
            self._switch_positions(5, 8)
        elif n_players == 7:
            self._switch_positions(1, 2)
            self._switch_positions(2, 3)
            self._switch_positions(3, 4)
            self._switch_positions(4, 6)
            self._switch_positions(5, 7)
            self._switch_positions(6, 8)
        elif n_players == 8:
            self._switch_positions(1, 2)
            self._switch_positions(2, 3)
            self._switch_positions(3, 4)
            self._switch_positions(4, 5)
            self._switch_positions(5, 6)
            self._switch_positions(6, 7)
            self._switch_positions(7, 8)

    def set_geometry(self, player, seat):
        geometries = self.geometries[seat]
        player_elements = self.player_elements[player]
        for key, value in player_elements.items():
            if type(value) != list:
                position = geometries[key]
                value.setGeometry(position)
            else:
                for i in range(len(value)):
                    position = geometries[key][i]
                    value[i].setGeometry(position)


    def setCardImage(self, label, card):
        # Construct the filename from the card's value and suit properties
        card_filename = f"{value_dict[card.value] if card.value >= 10 else card.value}{suit_dict[card.suit]}.png"
        card_path = f"cards/{card_filename}"  # Replace with the correct path
        pixmap = QPixmap(card_path)
        scaled_pixmap = pixmap.scaled(label.width(), label.height(), Qt.KeepAspectRatio, Qt.SmoothTransformation)
        label.setPixmap(scaled_pixmap)


    def showCards(self, player):
        self.setCardImage(self.player_elements[player]["cards"][0], self.game.players[player].holecards[0])
        self.player_elements[player]["cards"][0].setVisible(True)
        self.setCardImage(self.player_elements[player]["cards"][1], self.game.players[player].holecards[1])
        self.player_elements[player]["cards"][1].setVisible(True)

    def showBackside(self, player):
        card_filename = "default.png"
        card_path = f"cards/{card_filename}"  # Replace with the correct path
        pixmap = QPixmap(card_path)
        for element in self.player_elements[player]["cards"]:
            scaled_pixmap = pixmap.scaled(element.width(), element.height(), Qt.KeepAspectRatio, Qt.SmoothTransformation)
            element.setPixmap(scaled_pixmap)

    def muckCards(self, player):
        self.player_elements[player]["cards"][0].setVisible(False)
        self.player_elements[player]["cards"][1].setVisible(False)


    def fold(self):
        current_street = self.game.street
        # handle fold action
        index_next = self.game.players.index(self.game.acting_player)
        # Core logic for Call/Check

        action_text = "fold"
        self.player_elements[index_next]["action_label"].setText(action_text)
        self.player_elements[index_next]["action_label"].show()
        QTimer.singleShot(500, self.player_elements[index_next]["action_label"].hide)

        self.muckCards(index_next)
        game.implement_action(self.game.acting_player, 0)
        if self.game.street > current_street and not self.game.finished:
            self.deal_board(current_street)

        self._set_buttons()
        current_street = None if self.game.finished else 0
        self.check_end_of_round(current_street)
        if not mainWin.game.finished:
            self.update_ui_after_action()
        self.process_turn()

    def call(self):
        current_street = self.game.street
        player = self.game.acting_player  # Get the current player
        index_next = self.game.players.index(player)  # Get the player's index

        # Core logic for Call/Check
        if self.game.acting_player.bet == self.game.max_bet:  # Check condition
            action_text = "check"
        else:
            action_text = "call"
            #get betsize
            bet_label = self.player_elements[index_next]["bet"]
            betsize = min(self.game.max_bet, player.starting_stack)
            bet_label.setText(str(betsize))
            bet_label.setVisible(betsize > 0)
            chipcount_label = self.player_elements[index_next]["widget"].findChild(QLabel, f"chipcountPlayer_{index_next}")
            chipcount_label.setText(str(player.starting_stack-betsize))
        self.player_elements[index_next]["action_label"].setText(action_text)
        self.player_elements[index_next]["action_label"].show()
        QTimer.singleShot(500, self.player_elements[index_next]["action_label"].hide)


        self.game.implement_action(player, 1)  # Perform the Call/Check action


        # Handle street progression (if applicable)
        if self.game.street > current_street and not self.game.finished:
            update_pot = True
            self.deal_board(current_street)
        elif self.game.finished:
            update_pot = True
        else:
            update_pot = False

        # Update UI for human player only
        if player == self.human_player:
            self._set_buttons()  # Update button states for the human player

        # Handle round progression
        if self.game.finished:
            QTimer.singleShot(500, lambda: self.check_end_of_round(current_street))
        if not mainWin.game.finished:
            self.update_ui_after_action(update_pot)
        # Proceed to the next turn
        self.process_turn()

    def raiseBet(self, raise_amount=None):
        player = self.game.acting_player  # Get the current player
        index_next = self.game.players.index(player)  # Get the player's index

        # Core logic for Call/Check
        if self.game.max_bet == 0:  # Check condition
            action_text = "bet"
        else:
            action_text = "raise"
        self.player_elements[index_next]["action_label"].setText(action_text)
        self.player_elements[index_next]["action_label"].show()
        QTimer.singleShot(500, self.player_elements[index_next]["action_label"].hide)

        # Determine raise amount
        if not raise_amount:  # Human player: Use the GUI's input
            raise_amount = float(self.raiseAmountLineEdit.text())

        current_bet = player.bet

        # Execute the raise action
        self.game.implement_action(player, 2, raise_amount)

        # Update the bet label
        bet_label = self.player_elements[index_next]["bet"]
        bet_label.setText(str(player.bet))
        bet_label.setVisible(player.bet > 0)

        # Calculate and update the new stack
        change_in_bet = raise_amount - current_bet
        chipcount_label = self.player_elements[index_next]["widget"].findChild(QLabel, f"chipcountPlayer_{index_next}")
        current_stack = float(chipcount_label.text())
        new_stack_label = max(0, current_stack - change_in_bet)
        if int(new_stack_label) == float(new_stack_label):
            new_stack_label = int(new_stack_label)
        chipcount_label.setText(str(new_stack_label))

        # Handle UI updates
        if player == self.human_player:  # Only update buttons for human players
            self._set_buttons()

        # Handle end of the round and progress the game
        self.check_end_of_round()
        self.update_ui_after_action()
        self.process_turn()

    def deal_board(self, street):
        self.potLabel.setText("Pot: " + str(self.game.pot))
        for value in self.player_elements.values():
            value["bet"].setVisible(False)
        # street is the current street before dealing, so if flop is dealt, street i 0
        if street == 0:
            mainWin.setCardImage(self.flop_0, self.game.board[0])
            mainWin.setCardImage(self.flop_1, self.game.board[1])
            mainWin.setCardImage(self.flop_2, self.game.board[2])
        elif street == 1:
            mainWin.setCardImage(self.turn, self.game.board[3])

        elif street == 2:
            mainWin.setCardImage(self.river, self.game.board[4])


    def _set_buttons(self):
        if len(self.game.next) != 0:
            current_player = self.game.next[-1]  # Get the current player

            if current_player == self.human_player:  # Compare with the stored human player
                # Enable buttons for the human player
                self.foldButton.setEnabled(True)
                self.checkCallButton.setEnabled(True)
                self.betRaiseButton.setEnabled(True)

                # Update button text
                if self.game.max_bet == 0:
                    self.betRaiseButton.setText("Bet")
                else:
                    self.betRaiseButton.setText("Raise")

                if self.game.next[-1].bet == self.game.max_bet:
                    self.checkCallButton.setText("Check")
                    self.foldButton.setEnabled(False)
                else:
                    self.checkCallButton.setText("Call")
                    self.foldButton.setEnabled(True)

                # Update slider for betting
                minbet = self.game.get_legal_betsize()
                maxbet = self.game.next[-1].stack + self.game.next[-1].bet
                if minbet is not None:
                    self.raiseAmountLineEdit.setText(str(minbet))
                    self.betSizeSlider.setMinimum(minbet)
                    self.betSizeSlider.setMaximum(maxbet)
                    self.betSizeSlider.setValue(minbet)
            else:
                # Disable buttons when it's not the human player's turn
                self.foldButton.setEnabled(False)
                self.checkCallButton.setEnabled(False)
                self.betRaiseButton.setEnabled(False)

    def process_turn(self):
        if self.game.finished:  # Stop if the hand is over
            return

        for agent in self.ai_agents.values():
            state = agent.encode_state(game)
            agent.episodes[-1].add_observation(state)
            agent.add_to_sequence(state)
        current_player = self.game.acting_player
        if current_player == self.human_player:
            # It's the human player's turn - enable buttons and estimate values
            agent = self.ai_agents[current_player]
            sequence = agent.policy.create_sequence()
            legal_actions = list(self.game.get_legal_actions())
            valid_action_mask = torch.zeros(3, dtype=torch.bool)  # Initialize as all False
            valid_action_mask[legal_actions] = True
            valid_action_mask = valid_action_mask.reshape(1, 1, -1)
            with torch.no_grad():
                dist, _ = agent.policy(sequence, legal_actions_mask=valid_action_mask)
            probs = dist.category_probs[-1, -1, :].tolist()
            qs = sequence[-1, -1, -2:].tolist()
            self.p_fold.setText(str(round(probs[0], 4)))
            self.p_call.setText(str(round(probs[1], 4)))
            self.p_bet.setText(str(round(probs[2], 4)))
            self.q_call.setText(str(round(qs[0], 4)))
            self.q_bet.setText(str(round(qs[1], 4)))
            agent.policy.sequence_buffer = []
            self._set_buttons()
        else:
            # It's an AI player's turn - decide and execute an action
            self.process_ai_turn(current_player)

    def process_ai_turn(self, player):
        # Example AI logic
        action, betsize, *_ = self.ai_agents[player].get_action(game=game)
        if action == 0:
            QTimer.singleShot(1000,self.fold)
        elif action == 1:
            QTimer.singleShot(1000,self.call)
        else:
            QTimer.singleShot(1000, lambda: self.raiseBet(betsize))
    def update_ui_after_action(self, update_pot=False):
        # Update pot, chip counts, and bets
        if update_pot:
            self.potLabel.setText("Pot: " + str(self.game.pot))
        for i, player in enumerate(self.game.players):
            chipcount_label = self.player_elements[i]["widget"].findChild(QLabel, f"chipcountPlayer_{i}")
            chipcount_label.setText(str(player.stack))
            if not self.game.finished:
                bet_label = self.player_elements[i]["bet"]
                bet_label.setText(str(player.bet))
                bet_label.setVisible(player.bet > 0)

    def distribute_pot(self):
        for i in range(n_players):
            current_stack = float(self.player_elements[i]["widget"].findChild(QLabel, f"chipcountPlayer_{i}").text())
            pot = self.game.players[i].stack - current_stack
            if pot >0:
                bet_label = self.player_elements[i]["bet"]
                bet_label.setText(str("Pot: " + str(pot)))
                bet_label.setVisible(True)
                self.potLabel.setVisible(False)
            self.counts[i] += self.game.players[i].stack - self.game.players[i].starting_stack
        self.scores.clear()
        for player, score in zip(self.names, self.counts):
            self.scores.addItem(f"{player}: {score}")


    def check_end_of_round(self, street=None):
        if self.game.finished:
            self.potLabel.setText("Pot: " + str(self.game.pot))
            for i in range(n_players):
                self.player_elements[i]["bet"].setText("")
                mainWin.showCards(i)
            # check if there are cards to be dealt.
            if len(self.game.board) == 5:
                # Queue the UI updates for dealing cards with delays in between
                if street == 0 or street is None:  # If street is None, deal all streets
                    QTimer.singleShot(1000, lambda: self.deal_board(0))  # Deal flop after 1 sec
                    QTimer.singleShot(2000, lambda: self.deal_board(1))  # Deal turn after 2 secs
                    QTimer.singleShot(3000, lambda: self.deal_board(2))  # Deal river after 3 secs

                elif street == 1:
                    QTimer.singleShot(1000, lambda: self.deal_board(1))  # Deal turn after 1 sec
                    QTimer.singleShot(2000, lambda: self.deal_board(2))  # Deal river after 2 secs

                elif street == 2:
                    QTimer.singleShot(1000, lambda: self.deal_board(2))  # Deal river after 1 sec

            wait_till_pot = 4000 - street * 1000 if street is not None else 1000
                # Queue the chip count updates to occur after the last card is dealt
            # move pot to winner
            QTimer.singleShot(wait_till_pot, self.distribute_pot)

            wait_till_new_hand = 6000 - street * 1000 if street is not None else 2000
            QTimer.singleShot(wait_till_new_hand, self.deal_new_hand)
            self.buttonNextHand.setVisible(True)

    def update_chip_counts(self):
        # This function will update the chip counts after the board has been fully dealt
        for i in range(self.game.n_players):  # Assuming 'n_players' is defined
            chipcount_label = self.player_elements[i]["widget"].findChild(QLabel, f"chipcountPlayer_{i}")
            chipcount_label.setText(str(self.game.players[i].stack))


    def deal_new_hand(self):
        self.game.new_hand()
        player_button = self.game.next[-1] if n_players == 2 else self.game.positions[-1]
        index_button = self.game.players.index(player_button)
        for i in range(n_players):
            if i != index_button:
                self.player_elements[i]["button"].setVisible(False)
            else:
                self.player_elements[i]["button"].setVisible(True)
        for i in range(n_players):
            if i == 0:
                self.showCards(i)
            else:
                self.showBackside(i)
            chipcount_label = self.player_elements[i]["widget"].findChild(QLabel, f"chipcountPlayer_{i}")
            chipcount_label.setText(str(self.game.players[i].stack))
            bet = self.game.players[i].bet
            if bet > 0:
                self.player_elements[i]["bet"].setText(str(game.players[i].bet))
                self.player_elements[i]["bet"].setVisible(True)
        self.flop_0.clear()
        self.flop_1.clear()
        self.flop_2.clear()
        self.turn.clear()
        self.river.clear()
        self.potLabel.setText("Pot: ")
        self.potLabel.setVisible(True)
        mainWin._set_buttons()
        mainWin.buttonNextHand.setVisible(False)
        for agent in self.ai_agents.values():
            agent.policy.reset()
        self.process_turn()



def init_game(game, mainWin):
    game.new_hand(first_hand=True, random_seat=True)
    mainWin.names = [mainWin.labelPlayerName_0.text()]
    for i in range(1, n_players):
        mainWin.names.append("AI " + str(i))
    mainWin.counts = [0 for name in mainWin.names]

    # seat players according to order in game-instance. Player_0 always sits in the first seat because hero
    index_hero = game.positions.index(game.players[0])
    dummy_player = game.players[0]
    dummy_state = encode_state(game, dummy_player)
    dummy_cards = dummy_player.holecards
    dummy_strength = encode_strength(dummy_cards)
    state_vector_value =  np.hstack([dummy_state, dummy_strength])
    state_vector_value = state_vector_value.shape[0]
    value_functions = [
        GRUValueFunction(
            input_size=state_vector_value,
            hidden_size=256,
            num_gru_layers=1,
            linear_layers=(256, 128),
        ) for _ in range(len(game.players))
    ]
    policies = [
        MixedGruPolicy(
            input_size=state_vector_value + 2,
            hidden_size=256,
            num_gru_layers=1,
            linear_layers=(256, 128),
            value_function=v,
        ) for v in value_functions
    ]
    policy_paths = [f"../policies/saved_models/policy_6.pt" for _ in range(len(policies))]
    value_paths = [f"../value_functions/saved_models/model_6.pt" for _ in range(len(policies))]
    mainWin.ai_agents = {
        player: Agent(
            player,
            policy,
            value_function,
            True,
            policy_path=policy_path,
            value_path=value_path,
        ) for player, policy, value_function, policy_path, value_path in zip(
            game.players, policies, value_functions, policy_paths, value_paths
        )}
    mainWin.human_player = game.players[0]
    positions = [game.positions.index(game.players[i]) for i in range(n_players)]
    indices_next = [game.players.index(game.next[i]) for i in range(n_players)]
    mainWin.scores.clear()  # Clear existing items
    for player, score in zip(mainWin.names, mainWin.counts):
        mainWin.scores.addItem(f"{player}: {score}")

    print(positions)
    print(indices_next)
    for i in range(n_players):
        # find position player_0
        position = game.positions.index(game.players[i]) - index_hero
        if position < 0:
            position += n_players
        mainWin.set_geometry(i, position)


    player_button = game.next[-1] if n_players == 2 else game.positions[-1]
    index_button = game.players.index(player_button)
    for i in range(n_players):
        if i != index_button:
            mainWin.player_elements[i]["button"].setVisible(False)
    for i in range(n_players):
        if i == 0:
            mainWin.showCards(i)
        else:
            mainWin.showBackside(i)
        chipcount_label = mainWin.player_elements[i]["widget"].findChild(QLabel, f"chipcountPlayer_{i}")
        chipcount_label.setText(str(game.players[i].stack))
        bet = game.players[i].bet
        if bet > 0:
            mainWin.player_elements[i]["bet"].setText(str(game.players[i].bet))
        mainWin.player_elements[i]["action_label"].setVisible(False)
    mainWin._set_buttons()
    mainWin.buttonNextHand.setVisible(False)

if __name__ == "__main__":
    app = QApplication([])

    dialog = GameSetupDialog()
    if dialog.exec_():
        game_settings = dialog.get_inputs()
        n_players = game_settings["num_players"]
        starting_stacks = game_settings["starting_stacks"]

        print(game_settings)  # For now, just to confirm it's working
        game = Game(n_players, starting_stacks, hand_history=True)
        mainWin = PokerWindow(game_settings["username"], n_players=n_players, game_instance=game)


        init_game(game, mainWin)
        mainWin.show()
        mainWin.process_turn()
    app.exec_()



